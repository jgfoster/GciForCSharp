#ifndef GCITS_HF
#define GCITS_HF TRUE
/*=========================================================================
 * Copyright (C) GemTalk Systems 1986-2017.  All Rights Reserved.
 *
 * Name - gcits.hf
 *
 *  This file defines the entry points for the thread-safe GCI 
 *
 * $Id: gci.hf 31532 2013-09-25 19:41:53Z otisa $
 *
 *=========================================================================
 */
#include "flag.ht"

#include "gcicmn.ht"

// Functions for loading a GCI library
#include "gcirtl.hf"

// A pointer of type GciSession denotes a session .
typedef void* GciSession;

/*================================================
 * GciTsCallbackFType
 *  the signature of a callback function called at completion
 *  of a GciTsFork*  function .
 */
typedef void GciTsCallbackFType(GciSession sess, OopType result);

extern "C" {

/*================================================
 *  GciTsEncrypt
 *  Encrypts the clear text 'password'. Puts the encrypted form in
 *  outBuff and returns a pointer to the first character.
 *  Returns NULL if outBuff is not large enough, or password is NULL
 *  or an empty String.
 */
EXTERN_GCI_DEC(char*) GciTsEncrypt(const char* password, char *outBuf, size_t outBuffSize);

/*================================================
 *  GciTsLogin 
 *  Create a new session.  A netldi is contacted per the NRS GemService, and 
 *  optionally using HostUserId, HostPassword  to fork a gem process.
 *  Then the gem logs into the repository using StoneNameNrs, gemstoneUsername,
 *  gemstonePassword .
 *  Returns NULL if an error occurred, with details in *err .
 *  If result is non-NULL, login succeeded but there may still be a warning in *err .
 *  GCI_LOGIN_IS_SUBORDINATE bit in loginFlags is not allowed .
 *  "gcilnkobj" value for GemService is not allowed .
 *  GCI_LOGIN_PW_ENCRYPTED bit in loginFlags applies to gemstonePassword argument.
 *  haltOnErrNum, if non zero, specifes a value for GEM_HALT_ON_ERROR config parameter.
 *  Use GciTsEncrypt to encrypt passwords prior to calling GciTsLogin.
 *  If GemServiceNrs is NULL, the default "!@localhost!gemnetobject" is used .
 *  If StoneNameNrs is NULL, the default "gs64stone" is used
 *  HostUserId may be NULL if gem process is to run using the userId of the
 *  netldi  process .
 *
 *  Note, there are no equivalents to GciInit nor GciShutdown in the thread-safe GCI.
 *  The GciTsLogin function initializes all of the state related to the returned session
 *  and GciTsLogout will deallocate the specified session.
 */
EXTERN_GCI_DEC(GciSession) GciTsLogin(
    const char *StoneNameNrs,
    const char *HostUserId, 
    const char *HostPassword, BoolType hostPwIsEncrypted,
    const char *GemServiceNrs,
    const char *gemstoneUsername, const char *gemstonePassword,
    unsigned int loginFlags /* per GCI_LOGIN* in gci.ht */ ,
    int haltOnErrNum, GciErrSType *err);

/*================================================
 * GciTsForkLogin
 * Execute GciTsLogin in a separate C thread, calling *callback
 * when finished. Function result is TRUE if call initiated,
 *  FALSE if call could not be started, with details in *err 
 * 
 *  Upon completion, the first argument to the callback is
 *  the newly allocated session 
 *  and second argument is a SmallInteger value 0 for clean login,
 *  1 if a warning was returned  in *err 
 */
EXTERN_GCI_DEC(BoolType) GciTsForkLogin(
    const char *StoneNameNrs,
    const char *HostUserId, 
    const char *HostPassword, BoolType hostPwIsEncrypted,
    const char *GemServiceNrs,
    const char *gemstoneUsername, const char *gemstonePassword,
    unsigned int loginFlags /* per GCI_LOGIN* in gci.ht */ ,
    int haltOnErrNum, GciErrSType *err, 
    GciTsCallbackFType *callback);

/*================================================
 *  GciTsLogout
 *  Logout the session.
 *  If the return value is FALSE, an error is returned in *err.
 */
EXTERN_GCI_DEC(BoolType) GciTsLogout(GciSession sess, GciErrSType *err);

/*================================================
 *  GciTsSessionIsRemote
 *  Determinie if the given session is linked or RPC. 
 *  -1 indicates session is not valid, 0 is linked, and 1 is RPC. 
 *  Will not return 0 since linked sessions not currently supported
 */
EXTERN_GCI_DEC(int) GciTsSessionIsRemote(GciSession sess);

/*================================================
 *  GciTsGemTrace
 *  For use in debugging the implementation.
 *  note that the printSendTrace() and printRecvTrace in linkgc.hc
 *  may be sufficient in a slow build without needing GciGemTrace(1)
 *  enable = 0 none, 1 commands, 2 commands+args , 3 even more
 *  Function result is previous value of the tracing state.
 *  Also enabled by    export GS_LGC_DEBUG=1   or
 *  export GS_LGC_DEBUG=2 in enviroments of libgcirpc.so and of netldi .
 */
EXTERN_GCI_DEC(int) GciTsGemTrace(GciSession sess, int enable, GciErrSType *err);

/*================================================
 *  GciTsResolveSymbol
 *  Lookup a C string in a SymbolList
 *  result OOP_ILLEGAL if an error was returned in *err
 */
EXTERN_GCI_DEC(OopType) GciTsResolveSymbol(GciSession sess, 
	const char* str, OopType symbolList, GciErrSType *err);

/*================================================
 *  GciTsResolveSymbolObj
 *  Lookup a Symbol object in a SymbolList
 *  result OOP_ILLEGAL if an error was returned in *err
 */
EXTERN_GCI_DEC(OopType) GciTsResolveSymbolObj(GciSession sess, 
		OopType str, OopType symbolList, GciErrSType *err);

/*================================================
 *  GciTsGetFreeOops
 *
 *  result is number of Oops in buf, or -1 if an error was return in *err .
 */
EXTERN_GCI_DEC(int) GciTsGetFreeOops(GciSession sess, OopType *buf, int numOopsRequested, GciErrSType *err);

/*================================================
 *  GciTsSaveObjs
 *
 *  result TRUE if buf completely processed, FALSE if error returned in *err
 *  since GciTs does not support user actions, this always adds the objects
 *  to the PureExportSet .
 */
EXTERN_GCI_DEC(BoolType) GciTsSaveObjs(GciSession sess, OopType *buf, int count, GciErrSType *err);

/*================================================
 *  GciTsReleaseObjs
 *
 *  result TRUE if buf completely processed, FALSE if error returned in *err
 *  the inverse of GciTsSaveObjs
 */
EXTERN_GCI_DEC(BoolType) GciTsReleaseObjs(GciSession sess, OopType *buf, int count, GciErrSType *err);

/*================================================
 *  GciTsReleaseAllObjs
 *  result TRUE if successful, FALSE if error returned in *err
 */
EXTERN_GCI_DEC(BoolType) GciTsReleaseAllObjs(GciSession sess, GciErrSType *err);

/*================================================
 *  GciTsFetchBytes
 *
 *  function result is number of bytes returned in *dest or
 *  -1 if an error was returned in *err . *dest is undefined if
 *  result is -1.
 *  numBytes must be >= 0
 */
EXTERN_GCI_DEC(int64) GciTsFetchBytes(GciSession sess,
     OopType theObject, int64 startIndex, ByteType *dest, int64 numBytes,
     GciErrSType *err );

/*================================================
 *  GciTsFetchChars
 *
 *  Returns -1 if an error returned in *err , in which case
 *  strlen(cString) == 0 .
 *  maxSize must be >= 1;
 *  The bytes fetched are stored in memory
 *  starting at cString.  At most maxSize - 1 bytes will be fetched from
 *  the object, and a \0 character will be stored in memory following
 *  the bytes fetched.  The function returns the number of bytes fetched,
 *  excluding the null terminator character, which is equvalent to strlen(cString) 
 */
EXTERN_GCI_DEC(int64) GciTsFetchChars(GciSession sess,
         OopType theObject, int64 startIndex, char *cString, int64 maxSize,
         GciErrSType *err);

/*================================================
 *  GciTsFetchUtf8Bytes  
 *  
 *  class of aString must be a identical to or a subclass of
 *  String, MultiByteString or Utf8 .
 *  If aString is an instance of Utf8 , or a kind of String with
 *  all codePoints <= 127, *utf8String will be unchanged and behavior
 *  is the same as GciTsFetchBytes_ .  Note that the result buffer
 *  contains bytes and may not start or end at codePoint boundaries
 *  within an instance of Utf8 .
 *
 *  If aString is a kind of String or MultiByteString with codePoints
 *  above 127,  and startIndex == 1 then
 *  aString is sent encodeAsUTF8 and the result added to the export
 *  set and returned in *utf8String.
 *  Then bytes are fetched from *utf8String as for GciTsFetchBytes_ ,
 *  up to a maximum of bufSize. 
 *
 *  startIndex represents a byte offset into the Utf8 encoded result.
 *  If the function result == bufSize , then additional calls 
 *  with startIndex values of  bufSize*1, bufSize*2,  etc are needed
 *  to obtain the complete result.

 *  The caller should pass *utf8String to GciTsReleaseObjs
 *  after fetching all the bytes desired.
 *
 *  flags argument accepts these values
 *     0 = normal fetch 
 *     1 = substitute '.' for illegal codePoints
 *     2 = generate description in *buf instead of signalling an error
 *        when an illegal code point in aString prevents conversion to UTF8.
 *
 *  Returns -1 if an error was returned in *err , otherwise
 *  returns the number of bytes stored starting at *dest .
 *  There is no terminator zero included in *dest .
 */
EXTERN_GCI_DEC(int64) GciTsFetchUtf8Bytes(GciSession sess,
     OopType aString, int64 startIndex, ByteType *dest, int64 bufSize,
     OopType *utf8String, GciErrSType *err , int flags = 0);

/*================================================
 *  GciTsStoreBytes
 *
 *  Returns FALSE if an error returned in *err .
 *  ofClass specifies the class which theObject is an instance of .
 *  For an object with multiple bytes per character or digit,
 *  "theBytes" is assumed to be in client native byte order,
 *  and will be swizzled if needed on the server. Also, startIndex
 *  and numBytes must be aligned on character/digit boundaries. 
 */
EXTERN_GCI_DEC(BoolType) GciTsStoreBytes(GciSession sess,
     OopType theObject, int64 startIndex, ByteType *theBytes, int64 numBytes,
     OopType ofClass, GciErrSType *err );

/*================================================
 *  GciTsFetchOops
 *
 *  Returns -1 if an error returned in *err , otherwise returns the
 *  number of oops returned in *theOops , which will be <= numOops .
 *  startIndex must be >= 1 .
 *  numOops must be >= 0 . theOops must be non-NULL if numOops > 0. 
 */
EXTERN_GCI_DEC(int) GciTsFetchOops(GciSession sess,
  OopType theObject, int64 startIndex, OopType *theOops, int numOops,
  GciErrSType *err);
   
/*================================================
 *  GciTsStoreOops
 *
 */
EXTERN_GCI_DEC(BoolType) GciTsStoreOops(GciSession sess,
    OopType theObject, int64 startIndex,
    const OopType *theOops, int numOops, GciErrSType *err, BoolType overlay = FALSE);
  
/*================================================
 *  GciTsRemoveOopsFromNsc
 *
 *  Returns -1 if an error returned in *err, 
 *  0 if any element of theOops was not present in theNsc, 
 *  1 if all elements of theOops were present in theNsc 
 */
EXTERN_GCI_DEC(int) GciTsRemoveOopsFromNsc(GciSession sess, 
    OopType theNsc, const OopType *theOops,
    int numOops , GciErrSType *err);




class GciTsObjInfo {
 public:
  OopType       objId;
  OopType       objClass;                  /* OOP of the class of the obj */
  int64         objSize;                /* obj's total size, in bytes or OOPs*/
  int           namedSize;              /* num of named inst vars in the obj */
  uint access;  /* 0 no auth, 1 read allowed, 2 write allowed */
  unsigned short objectSecurityPolicyId;  // previously named segmentId
  unsigned short _bits;
  enum { 
     AUTH_NONE = 0, AUTH_READ = 1, AUTH_WRITE = 2 
  };
  enum {  // definitions of bits
      implem_mask    = GC_IMPLEMENTATION_MASK, // 0x03
      indexable_mask = GC_INDEXABLE_MASK,      // 0x04
      invariant_mask = GC_INVARIANT_MASK,      // 0x08
      partial_mask   = 0x10,
      overlay_mask   = 0x20,
      is_placeholder = 0x40 , // object is place holder for unsatisfied forward reference
      swiz_kind_mask = 0x300,
           swiz_kind_shift = 8
  };

  inline unsigned char isInvariant() { return _bits & invariant_mask; }
  inline unsigned char isIndexable() { return _bits & indexable_mask; }
  inline unsigned char isPartial()   { return _bits & partial_mask; }
  inline unsigned char isOverlayed() { return _bits & overlay_mask; }

  inline GciByteSwizEType byteSwizKind() const {
     return (GciByteSwizEType)((_bits & swiz_kind_mask) >> swiz_kind_shift) ;
  }

  inline unsigned char objImpl() {
    /* implementation format 0..3 , one of GC_FORMAT_OOP..GC_FORMAT_SPECIAL */
    return _bits & GC_IMPLEMENTATION_MASK;
  }
};



/*================================================
 *  GciTsFetchObjInfo
 *
 *  Function result is >= 0 for success or
 *  -1 if an error other than read authorization failure was returned in *err .
 *  client side handling of special objects as before.
 *  addToExportSet has effect only if function result is 1
 *  If buffer not NULL, then up to bufSize bytes of the body of the object
 *  are returned in *buffer, and function result is the number of instVars returned.
 *  If buffer == NULL then function result is 0 for success or -1 for error.
 *  If read authorization is denied for objId, then result->access == 0 ,
 *  the rest of *result other than result->objId is zero , and function result is zero.
 */
EXTERN_GCI_DEC(int64) GciTsFetchObjInfo(GciSession sess, OopType objId, 
	BoolType addToExportSet, GciTsObjInfo *result, 
	ByteType *buffer, size_t bufSize, GciErrSType *err);

/*================================================
 *  GciTsFetchSize
 *
 *  Returns number of named plus varying instVars of obj ,
 *  or -1 if an error was returned in *err.
 */
EXTERN_GCI_DEC(int64) GciTsFetchSize(GciSession sess, OopType obj, GciErrSType *err);

/*================================================
 *  GciTsFetchVaryingSize
 *
 *  Returns number of varying instVars of obj ,
 *  or -1 if an error was returned in *err.
 */
EXTERN_GCI_DEC(int64) GciTsFetchVaryingSize(GciSession sess, OopType obj, GciErrSType *err);

/*================================================
 *  GciTsFetchClass
 *
 *  Returns the oop of the class of obj,
 *  or OOP_ILLEGAL if an error was returned in *err
 */
EXTERN_GCI_DEC(OopType) GciTsFetchClass(GciSession sess, OopType obj, GciErrSType *err);

/*================================================
 *  GciTsObjExists
 *
 *  Returns TRUE if session is valid and obj exists,  FALSE otherwise.
 */
EXTERN_GCI_DEC(BoolType) GciTsObjExists(GciSession sess, OopType obj);

/*================================================
 *  GciTsIsKindOf
 *
 *  Equivalent to Object >> isKindOf:  where obj is the receiver
 *  and aClass is the argument .
 *  Returns -1 if an error was returned in *err, 
 *  0 for false result, 1 for true result
 */
EXTERN_GCI_DEC(int) GciTsIsKindOf(GciSession sess, 
		OopType obj, OopType aClass, GciErrSType *err);
/*================================================
 *  GciTsIsSubclassOf
 *
 *  Equivalent to Behavior >> isSubclassOf: where cls is the receiver
 *  and aClass is the argument.
 *  Returns -1 if an error was returne in *err, 0 for false result, 1 for true result.
 */
EXTERN_GCI_DEC(int) GciTsIsSubclassOf(GciSession sess, 
			OopType cls, OopType aClass, GciErrSType *err);

/*================================================
 *  GciTsIsKindOfClass
 *
 *  Equivalent to Object >> isKindOfClass:  where obj is the receiver
 *  and aClass is the argument.  
 *  Returns -1 if an error occurs, 0 for false result, 1 for true result
 */
EXTERN_GCI_DEC(int) GciTsIsKindOfClass(GciSession sess, 
		OopType obj, OopType aClass, GciErrSType *err);

/*================================================
 *  GciTsIsSubclassOfClass
 *
 *  Equivalent to Behavior >> _subclassOf: where cls is the receiver
 *  and aClass is the argument.
 *  Returns -1 if an error occurs, 0 for false result, 1 for true result
 */
EXTERN_GCI_DEC(int) GciTsIsSubclassOfClass(GciSession sess, 
			OopType cls, OopType aClass, GciErrSType *err);

/*================================================
 *  GciTsNewObj
 *
 *  Creates an instance of aClass with varying size zero .
 *  Returns OOP_ILLEGAL if an error was returned in *err .
 */
EXTERN_GCI_DEC(OopType) GciTsNewObj(GciSession sess, OopType aClass, GciErrSType *err);

/*================================================
 *  GciTsNewByteArray
 *
 *  Returns an an instance of ByteArray,
 *  or returns OOP_ILLEGAL if an error was returned in *err .
 */
EXTERN_GCI_DEC(OopType) GciTsNewByteArray(GciSession sess, 
		ByteType *body, size_t numBytes, GciErrSType *err);

/*================================================
 *  GciTsNewString_
 *  Create a String object from a C string, specifying size.
 *  Returns an instance of String,
 *  or returns OOP_ILLEGAL if an error was returned in *err .
 */
EXTERN_GCI_DEC(OopType) GciTsNewString_(GciSession sess, 
		const char *cString, size_t nBytes, GciErrSType *err);

/*================================================
 *  GciTsNewString
 *  Create a String object from a null-terminated C string.
 *  Returns an instance of String,
 *  or returns OOP_ILLEGAL if an error was returned in *err .
 */
EXTERN_GCI_DEC(OopType) GciTsNewString(GciSession sess, 
		const char *cString, GciErrSType *err);

/*================================================
 *  GciTsNewSymbol
 *  Create a Symbol from a C string
 *  Returns an instance of Symbol , 
 *  or returns OOP_ILLEGAL if an error was returned in *err .
 */
EXTERN_GCI_DEC(OopType) GciTsNewSymbol(GciSession sess, 
		const char *cString, GciErrSType *err);

/*================================================
 *  GciTsNewUnicodeString_
 *  Create a UnicodeString object from UTF-16 encoded data.
 *  Returns OOP_ILLEGAL if an error was returned in *err .
 *  Result will be an instance of Unicode7, Unicode16, or Unicode32 .
 *  str must be legal UTF-16 encoded data .
 */
EXTERN_GCI_DEC(OopType) GciTsNewUnicodeString_(GciSession s,
                        const ushort* str, size_t numShorts, GciErrSType *err);

/*================================================
 *  GciTsNewUnicodeString
 *  Create a UnicodeString object from UTF-16 encoded data.
 *  Returns OOP_ILLEGAL if an error was returned in *err .
 *  Result will be an instance of Unicode7, Unicode16, or Unicode32 .
 *  str must be legal UTF-16 encoded data.
 *  str is must be terminated by a codepoint of zero.
 */
EXTERN_GCI_DEC(OopType) GciTsNewUnicodeString(GciSession sess, 
		const ushort* str, GciErrSType *err);

/*================================================
 *  GciTsNewUtf8String
 * 
 *  Returns OOP_ILLEGAL if an error was returned in *err .
 *  utf8data must be legal UTF-8 data, terminated by a zero byte.
 *  If convertToUnicode==0, returns an instance of Utf8 .
 *  If convertToUnicode==1, returns an instance of
 *  Unicode7, Unicode16, or Unicode32 using the minimal
 *  character size required to represent utf8data.   
 *  If convertToUnicode==1 and utf8data is 7 bit ascii, 
 *  an instance of Unicode7 is returned.
 */
EXTERN_GCI_DEC(OopType) GciTsNewUtf8String(GciSession sess, 
		const char* utf8data, BoolType convertToUnicode,
                GciErrSType *err);

/*================================================
 *  GciTsNewUtf8String_
 *
 *  Returns OOP_ILLEGAL if an error was returned in *err .
 *  utf8data must contain nBytes bytes of legal UTF-8 data.
 *  If convertToUnicode==0, returns an instance of Utf8 .
 *  If convertToUnicode==1, returns an instance of
 *  Unicode7, Unicode16, or Unicode32 using the minimal
 *  character size required to represent utf8data.   
 *  If convertToUnicode==1 and utf8data is 7 bit ascii, 
 *  an instance of Unicode7 is returned 
 */
EXTERN_GCI_DEC(OopType) GciTsNewUtf8String_(GciSession sess, 
		const char* utf8data, size_t nBytes, BoolType convertToUnicode,
                GciErrSType *err);

/*================================================
 *  GciTsFetchUnicode
 *
 *  class of obj must be a identical to or a subclass of 
 *  String, DoubleByteString, or Unicode32 or Utf8 .
 *  destSize is the size of the buffer *dest in shorts .
 *  *dest will be filled with UTF-16 encoded Characters .
 *  Returns -1 if an error was returned in *err ,
 *  otherwise returns the number of codeunits (number of ushorts)
 *  that were stored at *dest.
 *  Returns in *requiredSize the number of shorts required to hold 
 *  the complete result including a terminator short of zero .
 *  If *requiredSize is > destSize, then *dest contains an incomplete
 *  result not terminated with a zero short.
 */
EXTERN_GCI_DEC(int64) GciTsFetchUnicode(GciSession sess,
     OopType obj, ushort *dest, int64 destSize, int64 *requiredSize,
     GciErrSType *err );

/*================================================
 *  GciTsFetchUtf8
 *
 *  class of obj must be a identical to or a subclass of 
 *  String, DoubleByteString, or Unicode32 or Utf8 .
 *  *dest will be filled with UTF-8 encoded Characters . 
 *  Returns -1 if an error was returned in *err , otherwise
 *  returns the number of bytes stored starting at *dest,
 *  excluding the zero terminator byte.
 *  Returns in *requiredSize the number of  bytes required
 *  to hold the complete result, including a terminator byte of zero.
 *  If *requiredSize is > destSize, then *dest contains an incomplete
 *  result not terminated with a zero byte.
 */
EXTERN_GCI_DEC(int64) GciTsFetchUtf8(GciSession sess,
     OopType obj, ByteType *dest, int64 destSize, int64 *requiredSize,
     GciErrSType *err );

/*================================================
 *  GciTsClearStack
 *
 *  returns FALSE if an error was returned in *err
 */
EXTERN_GCI_DEC(BoolType) GciTsClearStack(GciSession sess, OopType gsProcess, GciErrSType *err);

/*================================================
 *  GciTsPerform
 *
 *  returns OOP_ILLEGAL if an error was returned in *err .
 *  Either selector == OOP_ILLEGAL and selectorStr is used
 *  or else selectorStr == NULL and selector is used. 
 */
EXTERN_GCI_DEC(OopType) GciTsPerform(GciSession sess,
         OopType receiver,
         OopType aSymbol, const char* selectorStr,
         const OopType *args, int numArgs,
         int flags /* per GCI_PERFORM_FLAG* in gcicmn.ht */,
         ushort environmentId /* normally zero*/,  GciErrSType *err);

/*================================================
 * GciTsForkPerform
 * Execute GciTsPerform in a separate C thread, calling *callback
 * when finished. Function result is TRUE if call initiated,
 *  FALSE if call could not be started, with details in *err 
 */
EXTERN_GCI_DEC(BoolType) GciTsForkPerform(GciSession sess,
         OopType receiver,
         OopType aSymbol, const char* selectorStr,
         const OopType *args, int numArgs,
         int flags /* per GCI_PERFORM_FLAG* in gcicmn.ht */,
         ushort environmentId /* normally zero*/,  GciErrSType *err,
         GciTsCallbackFType *callback);

/*================================================
 *  GciTsPerformFetchBytes
 *
 *  send the specified selector to the specified receiver.
 *  If the result object is a byte format object, 
 *  returns contents of the result object in *result,
 *  without any NUL byte termination.
 *
 * Function result is the number of bytes returned in *result,
 * or -1  if an error was returned in *err
 *
 *  Either selector == OOP_ILLEGAL and selectorStr is used
 *  or else selectorStr == NULL and selector is used. 
 */
EXTERN_GCI_DEC(ssize_t) GciTsPerformFetchBytes(GciSession sess,
         OopType receiver,
         const char* selectorStr,
         const OopType *args, int numArgs,
         ByteType *result, ssize_t maxResultSize,
         GciErrSType *err);

/*================================================
 *  GciTsExecute
 *
 *  returns OOP_ILLEGAL if an error was returned in *err .
 *  If sourceStr is not NULL, it is used as the source string,
 *  and sourceOop specifies a class, typically OOP_CLASS_STRING or OOP_CLASS_Utf8,
 *  If sourceStr == NULL, then sourceOop is expected to be a kind of
 *  String, Unicode16, Unicode32, or Utf8 .
 *  If contextObj != OOP_ILLEGAL, source is compiled as if
 *  it were an instance method of the class of contextObj,
 *  otherwise compilation produces an anonymous method in which self == nil.
 *  If symbolList == OOP_NIL, use (System myUserProfile symbolList)
 *  to resolve literals in the compilation, otherwise use symbolList argument. 
 */
EXTERN_GCI_DEC(OopType) GciTsExecute(GciSession sess,
            const char* sourceStr, OopType sourceOop,
            OopType contextObject, OopType symbolList,
         int flags /* per GCI_PERFORM_FLAG* in gcicmn.ht */,
         ushort environmentId /* normally zero*/,  GciErrSType *err);

/*================================================
 * GciTsForkExecute
 * Execute GciTsExecute in a separate C thread, calling *callback
 * when finished. Function result is TRUE if call initiated,
 *  FALSE if call could not be started, with details in *err 
 */
EXTERN_GCI_DEC(BoolType) GciTsForkExecute(GciSession sess,
            const char* sourceStr, OopType sourceOop,
            OopType contextObject, OopType symbolList,
         int flags /* per GCI_PERFORM_FLAG* in gcicmn.ht */,
         ushort environmentId /* normally zero*/,  GciErrSType *err,
	 GciTsCallbackFType *callback);

/*================================================
 *  GciTsExecute_
 *
 *  variant of GciTsExecute . 
 *  If sourceSize == -1, strlen(sourceStr) is used for the size of the source
 */
EXTERN_GCI_DEC(OopType) GciTsExecute_(GciSession sess,
            const char* sourceStr, ssize_t sourceSize, OopType sourceOop,
            OopType contextObject, OopType symbolList,
         int flags /* per GCI_PERFORM_FLAG* in gcicmn.ht */,
         ushort environmentId /* normally zero*/,  GciErrSType *err);


/*================================================
 *  GciTsExecuteFetchBytes
 *
 *  variant of GciTsExecute_ which assumes that the execution result is
 *  a byte format object, usually an instance of String or Utf8 .
 *  The body of the result object is fetched into *result,
 *  and function result is number of bytes returned, or -1 if an error
 *  was returned in *err .
 *  Execution is in environment 0 using GCI_PERFORM_FLAG_ENABLE_DEBUG.
 */
EXTERN_GCI_DEC(ssize_t) GciTsExecuteFetchBytes(GciSession sess,
            const char* sourceStr, ssize_t sourceSize, OopType sourceOop,
            OopType contextObject, OopType symbolList,
         ByteType *result, ssize_t maxResultSize, GciErrSType *err);

/*================================================
 *  GciTsClassRemoveAllMethods
 *
 */
EXTERN_GCI_DEC(BoolType) GciTsClassRemoveAllMethods(GciSession sess, 
			OopType aClass, GciErrSType *err);

/*================================================
 *  GciTsProtectMethods
 *    if mode is TRUE, all subsequent method compilations in the
 *    current session will require a <protected> or <unprotected> token.
 *    until the function is called again with mode FALSE.
 *
 *    if mode is TRUE and the session is not logged in as SystemUser,
 *    the error RT_ERR_MUST_BE_SYSTEMUSER is generated, and no action is taken.
 */
EXTERN_GCI_DEC(BoolType) GciTsProtectMethods(GciSession sess, BoolType mode, GciErrSType *err);

/*================================================
 *  GciTsCompileMethod
 *  Compile a method. 
 *  result is the object id of a GsNMethod if successful
 *  result OOP_NIL, if a Warning was returned in *err
 *  result OOP_ILLEGAL if an error was returned in *err
 */
EXTERN_GCI_DEC(OopType) GciTsCompileMethod(GciSession sess,
     OopType source, OopType aClass, OopType category,
     OopType symbolList, OopType overrideSelector,
     int compileFlags, ushort environmentId, GciErrSType *err);

/*================================================
 *  GciTsContinueWith
 *
 *  result is OOP_ILLEGAL if an error was returned in *err .
 *  If continueWithError is not NULL, continue execution by signalling this
 *  error and replaceTopOfStack must be OOP_ILLEGAL . In this case,
 *  top frame of stack must be AbstractException>>signal
 *  or   AbstractException >>_signalFromPrimitive .
 *  Within *continueWithError, if continueWithError->exceptionObj is not OOP_NIL
 *  it is used to replace self in the top frame,
 *  otherwise continueWithError->number is used to construct a kind of
 *  AbstractException to replace self in the top frame.
 *  Then execution is restarted at start of top frame's method.
 * 
 *  replaceTopOfStack == OOP_ILLEGAL means TopOfStack will not be changed
 */
EXTERN_GCI_DEC(OopType) GciTsContinueWith(GciSession sess,
    OopType gsProcess, OopType replaceTopOfStack,
    GciErrSType *continueWithError,
    int flags,  /* same as GciPerformNoDebug flags, but single step has
                        no effect */
    GciErrSType *err);

/*================================================
 * GciTsForkContinueWith
 * Execute GciTsContinueWith in a separate C thread, calling *callback
 * when finished. Function result is TRUE if call initiated,
 *  FALSE if call could not be started, with details in *err 
 */
EXTERN_GCI_DEC(BoolType) GciTsForkContinueWith(GciSession sess,
    OopType gsProcess, OopType replaceTopOfStack,
    GciErrSType *continueWithError,
    int flags,  /* same as GciPerformNoDebug flags, but single step has
                        no effect */
    GciErrSType *err,
    GciTsCallbackFType *callback);

/*================================================
 * GciTsCallInProgress
 * Returns 1 if a call is in progress on the specified session,
 * 0 if a call is not in progress,
 * -1 if sess is invalid in which case *err contains the details
 */
EXTERN_GCI_DEC(int) GciTsCallInProgress(GciSession sess, GciErrSType *err);

/*================================================
 *  GciTsAbort
 *  Abort the specified session.
 *  Implemented in client library as message send
 */
EXTERN_GCI_DEC(BoolType) GciTsAbort(GciSession sess, GciErrSType *err);

/*================================================
 *  GciTsBegin
 *  Begin a new transaction.
 *  Implemented in client library as message send
 */
EXTERN_GCI_DEC(BoolType) GciTsBegin(GciSession sess, GciErrSType *err);

/*================================================
 *  GciTsCommit
 *  Commit the specified session.  
 *  Implemented in client library as message send
 */
EXTERN_GCI_DEC(BoolType) GciTsCommit(GciSession sess, GciErrSType *err);


/*================================================
 *  GciTsStoreTravDoTravRefs
 *
 *  Function result 0 = traversal completed, 
 *  1 = data returned but traversal not complete, -1 error in *err.
 *  If function result == 1, the application should call GciTsMoreTraversal 
 *  to fetch the remainder of the traversal result.
 *
 * This call  has several phases
 *  Phase 1
 *   Sends the oopsNoLongerReplicated, oopsGcedOnClient to the server,
 *     server removes oopsGcedOnClient from both PureExportSet and ReferencedSet,
 *       if an oop in oopsGcedOnClient is in neither PureExportSet nor ReferencedSet,
 *       or specifies a non-existant non-special object, no error is generated.
 *     server removes oopsNoLongerReplicated from the PureExportSet and
 *        adds them to the ReferencedSet .
 *       If any non-special object in oopsNoLongerReplicated
 *         was not actually in the PureExportSet, an error will be generated.
 *
 *  Phase 2, used the stdArgs argument and is equivalent to GciTsStoreTrav .
 *  stdArgs->storeTravBuff may be NULL if no store traversal phase
 *  is desired.
 *
 *  Note, stdArgs->alteredNumOops is ignored on input  .
 *   The output value of stdArgs->alteredNumOops is always zero,
 *   since altered objects are explicitly included in the traversal result.
 *
 *  Phase 3, the execution phase does one of
 *   GciPerformNoDebug, GciExecuteStrFromContextDbg, ExecuteBlock ,
 *     or no execution  per the stdArgs argument .
 *     See GciStoreTravDoArgsSType in gcicmn.ht for ExecuteBlock variant .
 *     This phase always uses GCI_PERFORM_RESULT_INTO_REFSET, to put
 *     non-special execution results into the ReferenceSet; the result may also
 *     be added to the PureExport set during the traversal phase below.
 *
 *  Phase 4 , does a special GciTsFetchTraversal .  The root of this traversal will
 *   be two objects (one object if Phase 3 was "no execution")
 *   The first root object (-->Phase 4A) is an array of all of the objects that
 *   would have been returned from a GciAlteredObjs call after Phase 3.
 *   The second root object (--Phase 4B)  is the execution result from Phase 3 .
 *   Phases 4A, 4B use the same clamp spec specified by *ctArgs.
 *   Phase 4A operates with level == (ctArgs->level + 1) , Phase 4B operates
 *   with ctArgs->level .
 *
 *   Objects reported during Phase 4A are objects in the PureExportSet that
 *   were changed since the more recent of the last GciStoreTravDoTravRefs
 *   or the last time the dirty object sets were cleared, plus any child
 *   objects not already in the PureExportSet .
 *
 *   Objects reported during Phase 4B are those objects not already in
 *   PureExportSet
 *
 *   Execution result is not automatically put in PureExportSet; it is handled as
 *     per the traversal.
 *   Objects referenced by the execution result that are in the PureExportSet
 *     are not reported, however they are not clamped and traversal is continued
 *     through them to the level specified by the clamp specification.
 *   Objects for which the ctArgs cause a full report to be sent are added to the
 *     PureExportSet if not already in the PureExportSet .
 *   Objects for which the ctArgs would cause a header-only report to be sent,
 *        if an obj is in PureExportSet, report nothing
 *        else if obj not already in ReferencedSet, generate a header only report
 *              and add to ReferencedSet
 *
 *   All instVar values in object reports that are non-special and
 *     not otherwise reported and not in the PureExportSet
 *     are added to the ReferencedSet for both the
 *     altered objects and the execution result traversals.
 *
 *   The addSubleafHeaders instVar of the ctArgs->clampSpec object
 *   controls whether header-only reports are sent for instVar values
 *   at the bottom level of the traversal.
 *
 *   This function always sets GCI_TRAV_WITH_REF_SET bit in ctArgs->retrievalFlags.
 *
 * The ReferencedSet protects its elements from GC ,
 *   but does not prevent committed objects from being faulted out of memory.
 *   There is no dirty tracking done on the ReferencedSet . The ReferencedSet
 *   represents those objects for which the client may have created a stub .
 *
 */
EXTERN_GCI_DEC(int) GciTsStoreTravDoTravRefs(GciSession sess,
    const OopType *oopsNoLongerReplicated, int numNotReplicated,
    const OopType *oopsGcedOnClient, int numGced,
    GciStoreTravDoArgsSType *stdArgs, GciClampedTravArgsSType *ctArgs,
    GciErrSType *err);

/*================================================
 *  GciTsForkStoreTravDoTravRefs 
 *  Execute GciTsStoreTravDoTravRefs in a separate C thread , calling
 *  *callback when finished.  Function result is TRUE if call initiated,
 *  FALSE if call could not be started, with details in *err .
 *
 *  Upon completion, the second argument to the
 *  callback is the int result of GciTsStoreTravDoTravRefs
 *  expressed as a SmallInteger.
 */
EXTERN_GCI_DEC(BoolType) GciTsForkStoreTravDoTravRefs(GciSession sess,
    const OopType *oopsNoLongerReplicated, int numNotReplicated,
    const OopType *oopsGcedOnClient, int numGced,
    GciStoreTravDoArgsSType *stdArgs, GciClampedTravArgsSType *ctArgs,
    GciErrSType *err,
    GciTsCallbackFType *callback);

/*================================================
 *  GciTsFetchTraversal
 *
 *  Performs a traversal starting at the oops specified by theOops and numOops,
 *  as specified by *ctArgs and flags, returning object reports in *travBuff .
 *  Returns 1 if traversal completed, 
 *  0 if data returned but traversal not complete,
 *  -1 if error returned in *err(in which case *travBuff undefined).
 *  If result == 1, call GciTsMoreTraversal again to fetch the remainder
 *  of the traversal result.   
 */
EXTERN_GCI_DEC(int) GciTsFetchTraversal(GciSession sess, 
        const OopType *theOops, int numOops,
        GciClampedTravArgsSType *ctArgs,
	GciTravBufType *travBuff, int flag, GciErrSType *err);

/*================================================
 *  GciTsStoreTrav
 *
 *  result FALSE if error returned in *err, otherwise TRUE
 */
EXTERN_GCI_DEC(BoolType) GciTsStoreTrav(GciSession sess, 
	GciTravBufType *travBuff, int flag, GciErrSType *err);

/*================================================
 *  GciTsMoreTraversal
 *
 *  function result 1 if traversal completed,
 *  0 if data returned but traversal not complete,
 *  -1 if an error was returned in *err (in which case *travBuff undefined)
 */
EXTERN_GCI_DEC(int) GciTsMoreTraversal(GciSession sess,
	GciTravBufType *travBuff, GciErrSType *err);

/*================================================
 *  GciTsOopIsSpecial
 *  Return true if the object is a special, false otherwise.
 */
EXTERN_GCI_DEC(BoolType) GciTsOopIsSpecial(OopType oop);

/*================================================
 *  GciTsFetchSpecialClass
 *  Fetch the class of a special object.
 *  If oop is a legal special object, returns the object id of the class of oop,
 *  otherwise returns OOP_ILLEGAL.
 *  For a legal special object the result will be one of
 *    OOP_CLASS_SMALL_DOUBLE
 *    OOP_CLASS_SMALL_INTEGER
 *    OOP_CLASS_UNDEFINED_OBJECT
 *    OOP_CLASS_BOOLEAN
 *    OOP_CLASS_CHARACTER
 *    OOP_CLASS_JIS_CHARACTER
 */
EXTERN_GCI_DEC(OopType)  GciTsFetchSpecialClass(OopType oop);

/*================================================
 *  GciTsOopToChar
 *
 *  if oop is a legal instance of Character 
 *  (i.e. if GciTsSpecialFetchClass(oop) == OOP_CLASS_CHARACTER)
 *  returns the code point of oop ,  otherwise returns -1.
 */
EXTERN_GCI_DEC(int) GciTsOopToChar(OopType oop);

/*================================================
 *  GciTsCharToOop
 *
 *  if  ch <= 0x10ffff  returns the oop of the corresponding 
 *  instance of Character, otherwise returns OOP_ILLEGAL 
 */
EXTERN_GCI_DEC(OopType) GciTsCharToOop(uint ch);

/*================================================
 *  GciTsDoubleToSmallDouble
 *
 *  If the the argument is representable as a SmallDouble , return the oop
 *  representing that value , otherwise return OOP_ILLEGAL 
 */
EXTERN_GCI_DEC(OopType) GciTsDoubleToSmallDouble(double aFloat);


/*================================================
 *  GciTsDoubleToOop
 *
 *  Returns OOP_ILLEGAL if an error was returned in *err, otherwise
 *  returns the oop of a Float or SmallDouble representing aFloat.
 *  Will operate without a valid session if the result is a SmallDouble 
 *  If aDouble is representable a SmallDouble, sess argument may be NULL .
 */
EXTERN_GCI_DEC(OopType) GciTsDoubleToOop(GciSession sess, double aDouble, GciErrSType *err);


/*================================================
 *  GciTsOopToDouble
 *
 *  Returns TRUE if oop is an instance of SmallDouble or Float 
 *  in which case the numeric value is returned in *result.
 *  If oop is a SmallDouble, sess argument may be NULL .
 *  Otherwise returns FALSE .
 */
EXTERN_GCI_DEC(BoolType) GciTsOopToDouble(GciSession sess, OopType oop,
	double *result, GciErrSType *err);

/*================================================
 *  GciI32ToOop
 *
 *  Returns an instance of SmallInteger representing the arg.
 */
EXTERN_GCI_DEC(OopType) GciI32ToOop(int arg);
  
/*================================================
 *  GciTsI64ToOop
 *
 *  Returns OOP_ILLEGAL if an error occurred while creating a LargeInteger result.
 *  otherwise returns an instance of SmallInteger or LargeInteger representing arg.
 *  If arg is representable as a SmallInteger, sess argument may be NULL.
 */
EXTERN_GCI_DEC(OopType) GciTsI64ToOop(GciSession sess, int64 arg, GciErrSType *err);

/*================================================
 *  GciTsOopToI64
 *
 *  If oop is a SmallInteger, or if oop is an instance of LargeInteger
 *  within the range of a 64bit signed integer , returns the C integer in *result,
 *  and returns a function result of TRUE.
 *  If oop a SmallInteger, sess argument may be NULL.
 *  Otherwise returns FALSE and *result is undefined and an error is returne in *err.
 */
EXTERN_GCI_DEC(BoolType) GciTsOopToI64(GciSession sess, OopType oop, int64 *result, GciErrSType *err);


/*================================================
 *  GciTsBreak
 *
 *  Sends hard or soft break, returns FALSE if an error returned in *err .
 *  May be called while another C thread has a call in progress using
 *  the same GciSession.  If no execution or traversal is in progress
 *  for the specified GciSession, has no effect.
 */
EXTERN_GCI_DEC(BoolType) GciTsBreak(GciSession sess, BoolType hard, GciErrSType *err);



typedef enum { gciSigNone, gciSigAbort, gciSigCommittedObjs, gciSigFinishTrans, 
               gciSignalFromSession,
               gciSigLostOt, gciSigLostSession } GciEventType ;


/*================================================
 *  GciTsWaitForEvent
 *
 *  To be called from a separate application thread, this call blocks
 *  until an event is available or the session is shutdown by a logout or
 *  fatal error, or until GciTsCancelWaitForEvent is called.
 *  events are gem-gem signal, sigAbort, sigLostot, loss of session
 *  function result 1 , *evout has details , 0 no signal present,
 *  -1 error is in *err .
 *  A possible error is that some other thread is already waiting in
 *  GciTsWaitForEvent for the specified session. 
 *  latencyMs defines how long this thread will sleep after the session 
 *  received data from the gem before it polls again for an event.
 */
EXTERN_GCI_DEC(int) GciTsWaitForEvent(GciSession sess, int latencyMs,
			GciEventType *evout, GciErrSType *err);

/*================================================
 *  GciTsCancelWaitForEvent
 *
 *  If result is FALSE, an error was returned in *err
 *  To be called from a thread other than the one waiting in GciTsWaitForEvent.
 *  causes any call to GciTsWaitForEvent to return.
 *  Has no effect if no thread is waiting in GciTsWaitForEvent for the specified
 *  session. 
 */
EXTERN_GCI_DEC(BoolType) GciTsCancelWaitForEvent(GciSession sess, GciErrSType *err);

/*================================================
 *  GciTsVersion
 *
 *  Can be called without a session.
 *  Function result is an integer indicating the GemStone product to which 
 *  the client library belongs. GciTsVersion will always return 3. 
 *  Defined integers are:
 *    1  GemStone/S
 *    2  GemStone/S 2G
 *    3  GemStone/S 64   (GciTsVersion returns this)
 *
 *  Returned in buf is a NUL terminated string that describes the GCI version.
 *  bufSize needs to be 128 or larger.
 *  Version fields in the string will be delimited by a '.'.
 *  The first field is the major version number,
 *  the second field is the minor version number.
 *  Any number of additional fields may exist. These
 *  additional fields will describe the exact release of the GCI.
 *  For additional version information use the methods in class System
 *  in the 'Version Management' category.
 */
EXTERN_GCI_DEC(uint) GciTsVersion(char *buf, size_t bufSize);

/* ===========================================================================
 * GciUtf8To8bit
 *
 * converts Utf8 input in *src to 8 bit data in *dest .
 * If all code points in *src are in the range 0..255, and the
 * result fits in destSize-1  , returns TRUE and *dest is null terminated,
 * otherwise returns FALSE.
 * Can be called without a session.
 */
EXTERN_GCI_DEC(BoolType) GciUtf8To8bit(const char* src, char *dest, ssize_t destSize);

/* ===========================================================================
 * GciNextUtf8Character
 *  For UTF-8 encoded src ,
 *  return the next legal UTF-8 code point in *chOut.
 *  Function result is the number of bytes in the that code point
 *  or -1 if the bytes are illegal for UTF-8 .
 * Can be called without a session.
 */
 EXTERN_GCI_DEC(ssize_t)
GciNextUtf8Character(const char* src, size_t len, uint *chOut);



/* xxx
DbgEstablishToFile
DbgLogString
    Richard suggests a server side method to append to this Dbg file also
    entries are timestamped.
    GsFile gciLogClient:  goes to this file .
    Want server debug data to be able to be logged without logging every gci call.
    So either separate files, or levels of logging like
      lev 0  - no logging
      lev 1  -  server gciLogClient and DbgLogString only
      lev 2  -  each gci call also logs
*/

// Step - use GciTsPerform to do a message send


}  /* extern "C" */

#include "gcistring.hf"

#endif 
